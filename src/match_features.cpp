#include <iostream>
#include <string>

#include <affine_invariant_features/feature_parameters.hpp>
#include <affine_invariant_features/target.hpp>
#include <affine_invariant_features/results.hpp>
#include <affine_invariant_features/result_matcher.hpp>

#include <opencv2/core.hpp>
#include <opencv2/features2d.hpp>

#include "aif_assert.hpp"

namespace aif = affine_invariant_features;

void readEverything(const std::string &path, aif::TargetData &target_data, aif::Results &results) {
  const cv::FileStorage file(path, cv::FileStorage::READ);
  AIF_Assert(file.isOpened(), "Could not open %s", path.c_str());

  aif::TargetDescription target_desc;
  file[target_desc.getDefaultName()] >> target_desc;
  AIF_Assert(!target_desc.path.empty(), "Could not load an image path from %s", path.c_str());

  target_data = target_desc.toData();
  AIF_Assert(!target_data.image.empty(), "Could not load an image described in %s", path.c_str());

  file[results.getDefaultName()] >> results;
  AIF_Assert(!results.keypoints.empty() && !results.descriptors.empty(),
             "Could not load extracted features from %s", path.c_str());
}

cv::Mat shadeImage(const cv::Mat &src, const cv::Mat &mask) {
  cv::Mat dst;
  if (mask.empty()) {
    dst = src.clone();
  } else {
    dst = src / 4;
    src.copyTo(dst, mask);
  }
  return dst;
}

int main(int argc, char *argv[]) {

  const cv::CommandLineParser args(
      argc, argv, "{ help | | }"
                  "{ @feature-file1 | <none> | can be generated by extract_features }"
                  "{ @feature-file2 | <none> | can be generated by extract_features }"
                  "{ @image | | optional output image }");

  if (args.has("help")) {
    args.printMessage();
    return 0;
  }

  const std::string feature_path1(args.get< std::string >("@feature-file1"));
  const std::string feature_path2(args.get< std::string >("@feature-file2"));
  const std::string image_path(args.get< std::string >("@image"));
  if (!args.check()) {
    args.printErrors();
    return 1;
  }

  aif::TargetData target1;
  aif::Results results1;
  readEverything(feature_path1, target1, results1);
  std::cout << "loaded " << results1.keypoints.size() << " feature points from " << feature_path1
            << std::endl;

  aif::TargetData target2;
  aif::Results results2;
  readEverything(feature_path2, target2, results2);
  std::cout << "loaded " << results2.keypoints.size() << " feature points from " << feature_path2
            << std::endl;

  aif::ResultMatcher matcher(results2);
  std::cout << "Matching feature points. This may take seconds." << std::endl;
  cv::Matx33f transform;
  std::vector< cv::DMatch > matches;
  matcher.match(results1, transform, matches);
  std::cout << "found " << matches.size() << " matches" << std::endl;

  const cv::Mat image1(shadeImage(target1.image, target1.mask));
  const cv::Mat image2(shadeImage(target2.image, target2.mask));
  cv::Mat image;
  cv::drawMatches(image1, results1.keypoints, image2, results2.keypoints, matches, image);

  std::cout << "Showing feature points and matches. Press any key to continue." << std::endl;
  cv::imshow("Matches", image);
  cv::waitKey(0);

  if (!image_path.empty()) {
    cv::imwrite(image_path, image);
    std::cout << "Wrote the result image to " << image_path << std::endl;
  }

  return 0;
}
