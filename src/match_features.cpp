#include <iostream>
#include <string>

#include <affine_invariant_features/feature_parameters.hpp>
#include <affine_invariant_features/target.hpp>
#include <affine_invariant_features/results.hpp>
#include <affine_invariant_features/result_matcher.hpp>

#include <opencv2/core.hpp>
#include <opencv2/features2d.hpp>

#include "aif_assert.hpp"

namespace aif = affine_invariant_features;

void loadAll(const std::string &path, cv::Ptr< aif::TargetData > &target_data,
             cv::Ptr< aif::Results > &results) {
  const cv::FileStorage file(path, cv::FileStorage::READ);
  AIF_Assert(file.isOpened(), "Could not open %s", path.c_str());

  target_data = aif::load< aif::TargetData >(file.root());
  AIF_Assert(target_data, "Could not load target data described in %s", path.c_str());

  results = aif::load< aif::Results >(file.root());
  AIF_Assert(results, "Could not load features from %s", path.c_str());
}

cv::Mat shade(const cv::Mat &src, const cv::Mat &mask) {
  cv::Mat dst(src / 4);
  src.copyTo(dst, mask);
  return dst;
}

int main(int argc, char *argv[]) {

  const cv::CommandLineParser args(
      argc, argv, "{ help | | }"
                  "{ @feature-file1 | <none> | can be generated by extract_features }"
                  "{ @feature-file2 | <none> | can be generated by extract_features }"
                  "{ @image | | optional output image }");

  if (args.has("help")) {
    args.printMessage();
    return 0;
  }

  const std::string feature_path1(args.get< std::string >("@feature-file1"));
  const std::string feature_path2(args.get< std::string >("@feature-file2"));
  const std::string image_path(args.get< std::string >("@image"));
  if (!args.check()) {
    args.printErrors();
    return 1;
  }

  cv::Ptr< aif::TargetData > target1;
  cv::Ptr< aif::Results > results1;
  loadAll(feature_path1, target1, results1);
  std::cout << "loaded " << results1->keypoints.size() << " feature points from " << feature_path1
            << std::endl;

  cv::Ptr< aif::TargetData > target2;
  cv::Ptr< aif::Results > results2;
  loadAll(feature_path2, target2, results2);
  std::cout << "loaded " << results2->keypoints.size() << " feature points from " << feature_path2
            << std::endl;

  aif::ResultMatcher matcher(results2);
  std::cout << "Matching feature points. This may take seconds." << std::endl;
  cv::Matx33f transform;
  std::vector< cv::DMatch > matches;
  matcher.match(*results1, transform, matches);
  std::cout << "found " << matches.size() << " matches" << std::endl;

  const cv::Mat image1(shade(target1->image, target1->mask));
  const cv::Mat image2(shade(target2->image, target2->mask));
  cv::Mat image;
  cv::drawMatches(image1, results1->keypoints, image2, results2->keypoints, matches, image);

  std::cout << "Showing feature points and matches. Press any key to continue." << std::endl;
  cv::imshow("Matches", image);
  cv::waitKey(0);

  if (!image_path.empty()) {
    cv::imwrite(image_path, image);
    std::cout << "Wrote the result image to " << image_path << std::endl;
  }

  return 0;
}
